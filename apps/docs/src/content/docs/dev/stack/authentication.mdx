---
title: Authentication
description: How authentication works across our applications using Supabase Auth, Svelte, and Astro
---

## Overview

Our authentication system is built on top of [Supabase Auth](https://supabase.com/docs/guides/auth), integrated with Svelte for state management and Astro for routing. The system is implemented in our shared `@sfh/backend` package, providing a consistent, secure, and type-safe authentication experience across all applications.

## Architecture

The authentication system consists of several key components working together:

### 1. Backend Authentication (`@sfh/backend`)

The core authentication functionality is centralized in our backend package:

```typescript
// Create an auth instance
import { createSupabaseAuth } from '@sfh/backend';

const auth = createSupabaseAuth(
  import.meta.env.PUBLIC_SUPABASE_URL,
  import.meta.env.PUBLIC_SUPABASE_ANON_KEY
);
```

The `Auth` class provides:
- User management and sessions
- Secure password hashing
- JWT tokens for session management
- Row Level Security (RLS) integration
- Type-safe authentication methods

### 2. Framework Integration

Our authentication system is designed to work with different frontend frameworks. Currently, we provide built-in support for Svelte stores:

```typescript
import { writable } from 'svelte/store';
import { createSvelteAuthStore } from '@sfh/backend';

export const authStore = createSvelteAuthStore({
  auth,
  createStore: writable,
});
```

### 3. Frontend Implementation

Applications can implement authentication using three main components:

#### Auth Instance

```typescript
// lib/auth.ts
import { createSupabaseAuth } from '@sfh/backend';

export const auth = createSupabaseAuth(
  import.meta.env.PUBLIC_SUPABASE_URL,
  import.meta.env.PUBLIC_SUPABASE_ANON_KEY
);

// Re-export auth methods for convenience
export const {
  signInWithEmail,
  signUp,
  signOut,
  getCurrentUser,
  onAuthStateChange,
} = auth;
```

#### Auth Store

```typescript
// lib/stores/auth.ts
import { writable } from 'svelte/store';
import { auth } from '../auth';
import { createSvelteAuthStore } from '@sfh/backend';

export const authStore = createSvelteAuthStore({
  auth,
  createStore: writable,
});
```

#### Protected Layout

```svelte
<!-- layouts/ProtectedLayout.svelte -->
<script lang="ts">
  import { onMount } from 'svelte';
  import { authStore } from '../lib/stores/auth';

  let mounted = false;

  onMount(() => {
    mounted = true;
  });

  $: if (mounted && !$authStore.loading && !$authStore.user) {
    window.location.href = '/login';
  }
</script>

{#if $authStore.loading}
  <div class="flex items-center justify-center min-h-screen">
    <div class="animate-spin rounded-full h-12 w-12 border-b-2 border-indigo-600"></div>
  </div>
{:else if $authStore.user}
  <slot />
{/if}
```

## Implementation Details

### Authentication Flow

1. **Login Process**:
   ```typescript
   import { auth } from '../lib/auth';
   
   async function handleLogin(email: string, password: string) {
     const { user } = await auth.signInWithEmail(email, password);
     // Handle successful login
   }
   ```

2. **Session Management**:
   - Sessions are managed by Supabase
   - Auth store syncs with Supabase's auth state
   - Real-time session updates through `onAuthStateChange`

3. **Protected Routes**:
   ```astro
   ---
   // dashboard.astro or any protected page
   import ProtectedLayout from '../layouts/ProtectedLayout.svelte';
   ---
   <ProtectedLayout client:load>
     <YourProtectedContent />
   </ProtectedLayout>
   ```

## Security Considerations

### Environment Variables

```bash
# Required for authentication
PUBLIC_SUPABASE_URL="your-project-url"
PUBLIC_SUPABASE_ANON_KEY="your-anon-key"

# For secure server-side operations
SUPABASE_SERVICE_KEY="your-service-key" # Never expose this
```

### Row Level Security (RLS)

All data access is controlled through RLS policies that integrate with the authentication system:

```sql
-- Example: Users can only access their own data
create policy "Users can only access their own data"
  on public.users
  for select
  using (auth.uid() = id);
```

## Usage Examples

### 1. Setting Up Authentication in a New App

```typescript
// 1. Create auth instance
import { createSupabaseAuth } from '@sfh/backend';
export const auth = createSupabaseAuth(
  import.meta.env.PUBLIC_SUPABASE_URL,
  import.meta.env.PUBLIC_SUPABASE_ANON_KEY
);

// 2. Create auth store (if using Svelte)
import { writable } from 'svelte/store';
import { createSvelteAuthStore } from '@sfh/backend';
export const authStore = createSvelteAuthStore({
  auth,
  createStore: writable,
});
```

### 2. Using Auth in Components

```typescript
<script lang="ts">
  import { authStore } from '../lib/stores/auth';
  import { auth } from '../lib/auth';

  async function handleSignOut() {
    await auth.signOut();
    window.location.href = '/login';
  }

  $: user = $authStore.user;
  $: isLoading = $authStore.loading;
</script>
```

## Best Practices

### Authentication Setup
- Always use the shared `@sfh/backend` package for authentication
- Configure environment variables properly
- Initialize auth early in your application

### Route Protection
- Always wrap protected content in `ProtectedLayout`
- Use RLS policies as the primary security mechanism
- Never rely solely on client-side auth checks

### Error Handling
- Always handle authentication errors gracefully
- Provide clear feedback to users
- Log authentication failures appropriately

### State Management
- Use the provided auth store for state management
- Avoid storing sensitive auth data in local storage
- Clear auth state properly on logout

### Performance
- Use `client:load` directive for auth components
- Implement loading states for better UX
- Cache auth state appropriately

## Testing

Our authentication system includes comprehensive test coverage across multiple levels, from unit tests to end-to-end testing.

### Test Utilities

We provide shared test utilities in `@sfh/testing` package to help with authentication testing:

```typescript
// packages/testing/src/auth.ts
import { createClient } from '@supabase/supabase-js';
import type { Database } from '@sfh/backend';

export const TEST_USER = {
  email: 'javiereh@pm.me',
  password: 'Stewart123!',
};

export async function setupTestUser() {
  // Delete the user if it exists
  const { data: existingUser } = await testClient.auth.admin.listUsers();
  const userToDelete = existingUser?.users.find(u => u.email === TEST_USER.email);
  if (userToDelete) {
    await testClient.auth.admin.deleteUser(userToDelete.id);
  }

  // Create the test user
  const { data, error } = await testClient.auth.admin.createUser({
    email: TEST_USER.email,
    password: TEST_USER.password,
    email_confirm: true,
  });

  if (error) throw error;
  return data.user;
}

export async function cleanupTestUser() {
  const { data: { users } } = await testClient.auth.admin.listUsers();
  const testUser = users.find(u => u.email === TEST_USER.email);
  if (testUser) {
    await testClient.auth.admin.deleteUser(testUser.id);
  }
}
```

### Unit Tests

Unit tests cover the core authentication functionality:

```typescript
// apps/admin/src/lib/__tests__/auth.test.ts
import { auth } from '../lib/auth';
import { setupTestUser, cleanupTestUser, TEST_USER } from '@sfh/testing/auth';

describe('Authentication', () => {
  beforeAll(async () => {
    await setupTestUser();
  });

  afterAll(async () => {
    await cleanupTestUser();
  });

  it('should successfully sign in with correct credentials', async () => {
    const { user } = await auth.signInWithEmail(TEST_USER.email, TEST_USER.password);
    expect(user?.email).toBe(TEST_USER.email);
  });

  it('should fail to sign in with incorrect password', async () => {
    await expect(
      auth.signInWithEmail(TEST_USER.email, 'wrongpassword')
    ).rejects.toThrow();
  });

  it('should successfully sign out', async () => {
    await auth.signInWithEmail(TEST_USER.email, TEST_USER.password);
    await auth.signOut();
    const currentUser = await auth.getCurrentUser();
    expect(currentUser).toBeNull();
  });
});
```

### End-to-End Tests

E2E tests verify the complete authentication flow in the browser:

```typescript
// apps/admin/e2e/auth.spec.ts
import { test, expect } from '@playwright/test';
import { setupTestUser, cleanupTestUser, TEST_USER } from '@sfh/testing/auth';

test.describe('Authentication Flow', () => {
  test.beforeAll(async () => {
    await setupTestUser();
  });

  test.afterAll(async () => {
    await cleanupTestUser();
  });

  test('should redirect to login page when accessing protected route', async ({ page }) => {
    await page.goto('/dashboard');
    await expect(page).toHaveURL('/login');
  });

  test('should login successfully and redirect to dashboard', async ({ page }) => {
    await page.goto('/login');
    
    await page.fill('input[type="email"]', TEST_USER.email);
    await page.fill('input[type="password"]', TEST_USER.password);
    await page.click('button[type="submit"]');

    await expect(page).toHaveURL('/dashboard');
    await expect(page.locator('h1')).toContainText('Admin Dashboard');
  });

  test('should logout successfully', async ({ page }) => {
    // Login first
    await page.goto('/login');
    await page.fill('input[type="email"]', TEST_USER.email);
    await page.fill('input[type="password"]', TEST_USER.password);
    await page.click('button[type="submit"]');

    // Then logout
    await page.click('button:has-text("Sign out")');
    await expect(page).toHaveURL('/login');
  });
});
```

### Running Tests

To run authentication tests, you'll need to set up the required environment variables:

```bash
# .env.test
PUBLIC_SUPABASE_URL="your-project-url"
PUBLIC_SUPABASE_ANON_KEY="your-anon-key"
SUPABASE_SERVICE_KEY="your-service-key"  # Required for test user management
```

Then run the tests:

```bash
# Run unit tests
npm run test

# Run E2E tests
npm run test:e2e
```

### Test Best Practices

1. **Test User Management**:
   - Always use the provided test utilities for user setup/cleanup
   - Never use production credentials in tests
   - Clean up test users after test completion

2. **Test Coverage**:
   - Test both successful and failure scenarios
   - Include edge cases (invalid credentials, network issues)
   - Test protected route access
   - Verify proper redirects and error messages

3. **Test Organization**:
   - Group related tests using `describe` blocks
   - Use clear, descriptive test names
   - Follow the Arrange-Act-Assert pattern

4. **Test Isolation**:
   - Each test should be independent
   - Clean up any state changes after tests
   - Don't rely on test execution order

5. **Environment Setup**:
   - Use separate test environment
   - Never connect to production database
   - Use environment variables for configuration

### Common Testing Patterns

1. **Testing Protected Routes**:
```typescript
test('should protect routes', async ({ page }) => {
  await page.goto('/dashboard');
  await expect(page).toHaveURL('/login');
});
```

2. **Testing Auth State**:
```typescript
test('should maintain auth state', async () => {
  await auth.signInWithEmail(TEST_USER.email, TEST_USER.password);
  const user = await auth.getCurrentUser();
  expect(user).toBeDefined();
});
```

3. **Testing Error Handling**:
```typescript
test('should handle errors', async ({ page }) => {
  await page.fill('input[type="email"]', TEST_USER.email);
  await page.fill('input[type="password"]', 'wrongpassword');
  await page.click('button[type="submit"]');
  
  const errorMessage = await page.waitForSelector('.text-red-600');
  expect(await errorMessage.isVisible()).toBeTruthy();
});
```

## Troubleshooting

Common issues and their solutions:

1. **Session Not Persisting**
   - Check if cookies are enabled
   - Verify SSL configuration
   - Ensure correct environment variables

2. **Protected Route Flashing**
   - Use `client:load` directive
   - Implement proper loading states
   - Check auth store initialization

3. **RLS Policy Issues**
   - Verify policy syntax
   - Check user authentication state
   - Test policies in Supabase Studio 